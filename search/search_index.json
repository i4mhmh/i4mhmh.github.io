{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mlscat: \u4e00\u53ea\u4f1a\u4fa7\u4fe1\u9053\u653b\u51fb\u7684\u5c0f\u732b","text":"<p>\u8fd9\u662f\u4e00\u53ea\u80fd\u5e2e\u52a9\u4f60\u5feb\u901f\u5b9e\u73b0\u4fa7\u4fe1\u9053\u653b\u51fb\u7684\u5c0f\u732b\uff0c\u5feb\u6765\u64b8\u5b83\uff01</p>"},{"location":"#_1","title":"\u7279\u6027","text":"<ul> <li>\u591a\u4e2a\u7b80\u5355\u7684\u4fa7\u4fe1\u9053\u653b\u51fb\u6a21\u5757\u3002</li> <li>\u5bf9\u73b0\u6709\u6280\u672f\u8fdb\u884c\u6574\u5408\uff0c\u5373\u63d2\u5373\u7528\uff01</li> <li>\u51cf\u5c11\u91cd\u590d\u64cd\u4f5c</li> <li>\u5bb9\u6613\u4e0a\u624b</li> </ul>"},{"location":"#_2","title":"\u4f7f\u7528\u65b9\u6cd5","text":"<p>\u5b89\u88c5</p> <pre><code>pip install mlscat\n</code></pre> <p>\u4f7f\u7528</p> <pre><code>&gt;&gt;&gt; import mlscat as cat\n&gt;&gt;&gt; cat.__version__\n'x.x.x'\n</code></pre>"},{"location":"#_3","title":"\u6a21\u5757","text":"<p>\u6211\u4eec\u76ee\u524d\u5c1d\u8bd5\u5212\u5206\u516d\u4e2a\u6a21\u5757\u6765\u7ec4\u6210\u653b\u51fb\u5e93</p> <ol> <li><code>data</code>\uff1a\u52a0\u8f7d\u6570\u636e\u3001\u5bf9\u6570\u636e\u8fdb\u884c\u9884\u5904\u7406\u6a21\u5757</li> <li> <p><code>leakage</code>\uff1a\u6cc4\u9732\u6a21\u578b\u6a21\u5757</p> </li> <li> <p><code>attacks</code>\uff1a\u8d1f\u8d23\u4fa7\u4fe1\u9053\u653b\u51fb\u4e2d\u6838\u5fc3\u653b\u51fb\u7684\u6a21\u5757</p> </li> <li><code>metrics</code>\uff1a\u6a21\u578b\u653b\u51fb\u6307\u6807</li> <li><code>security</code>\uff1a\u5b58\u653e\u5404\u79cd\u5bf9\u6297\u63aa\u65bd</li> <li><code>utils</code>\uff1a\u4e00\u4e9b\u6742\u9879</li> </ol>"},{"location":"#_4","title":"\u5feb\u901f\u5f00\u59cb","text":""},{"location":"#_5","title":"\u5f00\u53d1\u8bb0\u5f55","text":"<pre><code># \u5f00\u53d1\u65e5\u5fd7\n\n- \u65e5\u671f: 2024\u5e745\u670816\u65e5\n- \u7248\u672c:0.1.0\n- \u5185\u5bb9:\n    \u7b2c\u4e00\u7248\u5e93\u7ec8\u4e8e\u66f4\u65b0\u597d\u4e86\uff0c\u867d\u7136\u5185\u5bb9\u6bd4\u8f83\u5c11\u800c\u4e14\u4ee3\u7801\u6bd4\u8f83\u6742\uff0c\u4f46\u603b\u7b97\u80fd\u7528\u4e86\uff01\n</code></pre>"},{"location":"attack/","title":"attacks\u6a21\u5757","text":"<p>\u4e00\u4e9b\u6838\u5fc3\u653b\u51fb\u4ee3\u7801\u96c6\u6210</p>"},{"location":"attack/#cpa","title":"CPA","text":"<p><code>cat.attacks.cpa(byte_idx, plaintexts, traces, mask_scheme=None, mask=-1)-&gt;np.ndarray</code></p> <p>\u6267\u884c\u76f8\u5173\u6027\u80fd\u91cf\u5206\u6790\uff08Correlation Power Analysis, CPA\uff09\uff0c\u7528\u4e8e\u4ece\u52a0\u5bc6\u8bbe\u5907\u7684\u80fd\u91cf\u8ff9\u4e2d\u6062\u590d\u6307\u5b9a\u4f4d\u7f6e\u7684\u5bc6\u94a5\u5b57\u8282\u3002</p> <p>\u53c2\u6570</p> <ul> <li> <p><code>byte_idx</code> (<code>int</code>)   \u8981\u653b\u51fb\u7684\u5bc6\u94a5\u5b57\u8282\u7d22\u5f15\uff08\u4f8b\u5982\uff1a0\u201315 \u5bf9\u4e8e AES-128\uff09\u3002</p> </li> <li> <p><code>plaintexts</code> (<code>numpy.ndarray</code>)   \u8f93\u5165\u660e\u6587\u6570\u636e\uff0c\u5f62\u72b6\u4e3a <code>(N, L)</code> \u6216 <code>(N,)</code>\uff0c\u5176\u4e2d <code>N</code> \u662f\u80fd\u91cf\u8ff9\u7684\u6570\u91cf\uff0c<code>L</code> \u662f\u6bcf\u6761\u660e\u6587\u7684\u5b57\u8282\u6570\u3002</p> </li> <li> <p><code>traces</code> (<code>numpy.ndarray</code>)   \u80fd\u91cf\u8ff9\u6570\u636e\uff0c\u4e8c\u7ef4\u6570\u7ec4\uff0c\u5f62\u72b6\u4e3a <code>(N, T)</code>\uff0c<code>N</code> \u662f\u80fd\u91cf\u8ff9\u7684\u6570\u91cf\uff0c<code>T</code> \u4e3a\u6bcf\u6761\u80fd\u91cf\u8ff9\u7684\u65f6\u95f4\u6837\u672c\u70b9\u4e2a\u6570\u3002\u5fc5\u987b\u4e0e <code>plaintexts</code> \u7684\u6570\u91cf\u4e00\u81f4\u3002</p> </li> <li> <p><code>mask_scheme</code> (<code>str</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>None</code>)   \u63a9\u7801\u9632\u62a4\u65b9\u6848\u7c7b\u578b\uff08\u76ee\u524d\u4ec5\u6709<code>bool</code>\u53ef\u9009\uff09\u3002  </p> </li> <li> <p><code>mask</code> (<code>int</code>, <code>list</code>, \u6216 <code>numpy.ndarray</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>-1</code>)   \u63a9\u7801\u503c\u6216\u63a9\u7801\u5e8f\u5217\uff0c\u5f62\u72b6\u4e3a <code>(N,)</code>\u3002  </p> </li> </ul> <p>\u8fd4\u56de\u503c</p> <ul> <li><code>np.ndarray</code>   \u63a8\u6d4b\u51fa\u7684\u6700\u4f73\u5bc6\u94a5\u503c\uff0c\u8fd4\u56de\u5f62\u5f0f\u4e3a <code>np.array([best_key])</code>\uff0c\u5176\u4e2d <code>best_key</code> \u662f\u6700\u53ef\u80fd\u7684\u5bc6\u94a5\u5b57\u8282\uff080\u2013255\uff09\u3002</li> </ul> <p>\u793a\u4f8b</p> <pre><code>import mlscat\nimport numpy as np\n\n# \u793a\u4f8b\u6570\u636e\nplaintexts = np.array([[0x32, 0x43, 0xf1, 0xa4], \n                       [0x32, 0x43, 0xf1, 0xa5], \n                       [0x32, 0x43, 0xf1, 0xa6]])\ntraces = np.random.rand(3, 1000)\n\n# \u6267\u884c CPA \u653b\u51fb\nguess_key = mlscat.attacks.cpa(byte_idx=3, plaintexts=plaintexts, traces=traces)\n\nprint(\"\u63a8\u6d4b\u5bc6\u94a5\u5b57\u8282:\", guess_key)  # \u8f93\u51fa: \u63a8\u6d4b\u5bc6\u94a5\u5b57\u8282\n</code></pre>"},{"location":"attack/#dpa","title":"DPA","text":"<p><code>cat.attacks.dpa(traces, plaintexts, threshold, target_byte, target_point, leakage_function)</code> </p> <p>\u6267\u884c\u5dee\u5206\u80fd\u91cf\u5206\u6790\uff08Differential Power Analysis, DPA\uff09\uff0c\u7528\u4e8e\u4ece\u52a0\u5bc6\u8bbe\u5907\u7684\u80fd\u91cf\u8ff9\u4e2d\u6062\u590d AES-128 \u7684\u5bc6\u94a5\u5b57\u8282\u3002 \u8be5\u51fd\u6570\u57fa\u4e8e\u6307\u5b9a\u7684\u6cc4\u6f0f\u6a21\u578b\uff08\u5982\u6c49\u660e\u91cd\u91cf\uff09\u5c06\u80fd\u91cf\u8ff9\u5206\u4e3a\u4e24\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u7ec4\u5728\u76ee\u6807\u91c7\u6837\u70b9\u4e0a\u7684\u5747\u503c\u5dee\u5f02\uff0c\u4ece\u800c\u63a8\u6d4b\u6700\u53ef\u80fd\u7684\u5bc6\u94a5\u5019\u9009\u3002 </p> <p>\u26a0\ufe0f \u6ce8\u610f\uff1a\u5f53\u524d\u5b9e\u73b0\u4e13\u4e3a AES-128 \u8bbe\u8ba1\u3002\u82e5\u7528\u4e8e AES-192\u3001AES-256 \u6216\u5176\u4ed6\u7b97\u6cd5\uff0c\u9700\u624b\u52a8\u4fee\u6539\u4e2d\u95f4\u503c\u8ba1\u7b97\u903b\u8f91\u3002 </p> <p>\u53c2\u6570 </p> <ul> <li> <p><code>traces</code> (<code>numpy.ndarray</code>)    </p> <p>\u80fd\u91cf\u8ff9\u6570\u636e\uff0c\u5f62\u72b6\u4e3a <code>(N, T)</code>\uff0c\u5176\u4e2d <code>N</code> \u662f\u8ff9\u7684\u6570\u91cf\uff0c<code>T</code> \u662f\u6bcf\u6761\u8ff9\u7684\u91c7\u6837\u70b9\u6570\u3002</p> </li> <li> <p><code>plaintexts</code> (<code>numpy.ndarray</code>) </p> <p>\u5bf9\u5e94\u7684\u660e\u6587\u6570\u636e\uff0c\u5f62\u72b6\u4e3a <code>(N, 16)</code>\uff08\u9002\u7528\u4e8e AES-128\uff09\u3002\u6bcf\u6761\u660e\u6587\u5e94\u4e3a 16 \u5b57\u8282\u3002</p> </li> <li> <p><code>threshold</code> (<code>int</code>)   \u7528\u4e8e\u5206\u7ec4\u7684\u9608\u503c\u3002\u6839\u636e\u6cc4\u6f0f\u51fd\u6570\u7684\u8f93\u51fa\u503c\u4e0e\u8be5\u9608\u503c\u6bd4\u8f83\uff0c\u5c06\u8ff9\u5212\u5206\u4e3a\u4e24\u7ec4\uff1a</p> </li> <li>\u5c0f\u4e8e\u9608\u503c \u2192 \u7ec41</li> <li>\u5927\u4e8e\u7b49\u4e8e\u9608\u503c \u2192 \u7ec42</li> <li><code>target_byte</code> (<code>int</code>)   \u8981\u653b\u51fb\u7684\u5bc6\u94a5\u5b57\u8282\u7d22\u5f15\uff080\u201315\uff09\uff0c\u7528\u4e8e\u8ba1\u7b97\u4e2d\u95f4\u503c <code>SBox[plaintext[target_byte] ^ key_guess]</code>\u3002</li> <li><code>target_point</code> (<code>int</code>)   \u5728\u6bcf\u6761\u80fd\u91cf\u8ff9\u4e2d\u8981\u5206\u6790\u7684\u91c7\u6837\u70b9\u7d22\u5f15\uff08\u4f8b\u5982\uff1a810\uff09\u3002\u653b\u51fb\u57fa\u4e8e\u8be5\u70b9\u7684\u80fd\u91cf\u503c\u8fdb\u884c\u5206\u7ec4\u5747\u503c\u5206\u6790\u3002</li> <li><code>leakage_function</code> (<code>str</code>)   \u4f7f\u7528\u7684\u6cc4\u6f0f\u6a21\u578b\uff1a</li> <li><code>'hw'</code>\uff1a\u4f7f\u7528\u6c49\u660e\u91cd\u91cf\uff08Hamming Weight\uff09\u4f5c\u4e3a\u5206\u7c7b\u4f9d\u636e</li> <li>\u5176\u4ed6\u503c\uff1a\u76f4\u63a5\u4f7f\u7528 S \u76d2\u8f93\u51fa\u503c\uff08\u4e0d\u63a8\u8350\uff0c\u901a\u5e38 <code>'hw'</code> \u66f4\u6709\u6548\uff09</li> </ul> <p>\u8fd4\u56de\u503c</p> <ul> <li><code>candidate_key</code> (<code>int</code>)   \u63a8\u6d4b\u51fa\u7684\u6700\u53ef\u80fd\u5bc6\u94a5\u5b57\u8282\uff080\u2013255\uff09\uff0c\u5bf9\u5e94\u6700\u5927\u5747\u503c\u5dee\u7684\u5bc6\u94a5\u731c\u6d4b\u3002</li> <li><code>mean_diffs</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(256,)</code>)   \u6240\u6709 256 \u4e2a\u5bc6\u94a5\u731c\u6d4b\u5bf9\u5e94\u7684\u4e24\u7ec4\u8ff9\u5728 <code>target_point</code> \u5904\u7684\u5747\u503c\u5dee\u7edd\u5bf9\u503c\u6570\u7ec4\uff0c\u53ef\u7528\u4e8e\u8fdb\u4e00\u6b65\u5206\u6790\u6216\u7ed8\u56fe\u3002</li> </ul> <p>\u793a\u4f8b</p> <pre><code>import mlscat\nimport numpy as np\n\n# \u5047\u8bbe\u5df2\u91c7\u96c6\u6570\u636e\ntraces = np.load('traces.npy')       # shape: (2000, 15000)\nplaintexts = np.load('plain.npy')    # shape: (2000, 16)\n\n# \u6267\u884c DPA \u653b\u51fb\uff1a\u653b\u51fb\u7b2c 0 \u5b57\u8282\uff0c\u5728\u91c7\u6837\u70b9 810 \u5206\u6790\uff0c\u4f7f\u7528\u6c49\u660e\u91cd\u91cf\u6a21\u578b\uff0c\u9608\u503c\u4e3a 4\ncandidate, diffs = mlscat.attacks.dpa(\n    traces=traces,\n    plaintexts=plaintexts,\n    threshold=4,\n    target_byte=0,\n    target_point=810,\n    leakage_function='hw'\n)\n\nprint(\"\u63a8\u6d4b\u5bc6\u94a5\u5b57\u8282:\", candidate)  \n</code></pre>"},{"location":"attack/#templateattack","title":"TemplateAttack","text":"<p>\u6a21\u677f\u653b\u51fb\uff08Template Attack, TA\uff09\u2014\u2014 \u4e00\u79cd\u9ad8\u9636\u4fa7\u4fe1\u9053\u5206\u6790\u65b9\u6cd5\uff0c\u57fa\u4e8e\u5efa\u6a21\u9636\u6bb5\u7684\u7edf\u8ba1\u7279\u5f81\u5bf9\u653b\u51fb\u9636\u6bb5\u6570\u636e\u8fdb\u884c\u5bc6\u94a5\u63a8\u6d4b\u3002</p> <p><code>TemplateAttack</code> \u7c7b\u5b9e\u73b0\u4e86\u7ecf\u5178\u7684\u57fa\u4e8e\u591a\u5143\u9ad8\u65af\u5206\u5e03\u7684\u6a21\u677f\u653b\u51fb\uff0c\u5206\u4e3a\u4e24\u4e2a\u9636\u6bb5\uff1a</p> <ol> <li>\u6a21\u677f\u6784\u5efa\u9636\u6bb5\uff08<code>profiling</code>\uff09\uff1a\u4ece\u80fd\u91cf\u8ff9\u6570\u636e\u4e2d\u5b66\u4e60\u6bcf\u4e2a\u4e2d\u95f4\u503c\u7c7b\u522b\u7684\u5747\u503c\u4e0e\u534f\u65b9\u5dee\u77e9\u9635\u3002</li> <li>\u653b\u51fb\u9636\u6bb5\uff08<code>attack</code>\uff09\uff1a\u4f7f\u7528\u6a21\u677f\u5bf9\u672a\u77e5\u5bc6\u94a5\u7684\u653b\u51fb\u6570\u636e\u8fdb\u884c\u6982\u7387\u63a8\u65ad\uff0c\u5e76\u8ba1\u7b97\u5e73\u5747\u6392\u540d\uff08Mean Rank\uff09\u4ee5\u8bc4\u4f30\u5bc6\u94a5\u6062\u590d\u80fd\u529b\u3002</li> </ol> <pre><code>class TemplateAttack:\n    def __init__(self, X_profiling, Y_profiling, X_attack) -&gt; None:\n        \"\"\"\n        \u521d\u59cb\u5316\u6a21\u677f\u653b\u51fb\u5bf9\u8c61\u3002\n\n        \u53c2\u6570:\n            X_profiling (np.ndarray): \u914d\u7f6e\u9636\u6bb5\u7684\u80fd\u91cf\u8ff9\uff0c\u5f62\u72b6\u4e3a (N_prof, T)\u3002\n            Y_profiling (np.ndarray): \u914d\u7f6e\u9636\u6bb5\u7684\u4e2d\u95f4\u503c\u6807\u7b7e\uff0c\u5f62\u72b6\u4e3a (N_prof,)\u3002\n            X_attack (np.ndarray): \u653b\u51fb\u9636\u6bb5\u7684\u80fd\u91cf\u8ff9\uff0c\u5f62\u72b6\u4e3a (N_attack, T)\u3002\n\n</code></pre>"},{"location":"attack/#pcc","title":"PCC","text":"<p>\u8ba1\u7b97\u76ae\u5c14\u900a\u76f8\u5173\u7cfb\u6570\uff08Pearson Correlation Coefficient\uff09\u5411\u91cf\uff0c\u7528\u4e8e\u4fa7\u4fe1\u9053\u5206\u6790\u4e2d\u8861\u91cf\u4e2d\u95f4\u503c\u731c\u6d4b\u4e0e\u80fd\u91cf\u8ff9\u5404\u91c7\u6837\u70b9\u4e4b\u95f4\u7684\u7ebf\u6027\u76f8\u5173\u6027\u3002</p> <p>\u8be5\u51fd\u6570\u5bf9\u6bcf\u4e00\u6761\u8ff9\u7684\u6bcf\u4e2a\u91c7\u6837\u70b9\u5206\u522b\u8ba1\u7b97\u4e0e\u7ed9\u5b9a\u76ee\u6807\u4e2d\u95f4\u503c\u5e8f\u5217\u7684\u76f8\u5173\u6027\uff0c\u8fd4\u56de\u7edd\u5bf9\u503c\u5f62\u5f0f\u7684\u76f8\u5173\u7cfb\u6570\u6570\u7ec4\uff0c\u4fbf\u4e8e\u540e\u7eed\u5206\u6790\uff08\u5982 CPA \u653b\u51fb\u4e2d\u5bfb\u627e\u6700\u5927\u76f8\u5173\u70b9\uff09\u3002</p>"},{"location":"attack/#_1","title":"\u53c2\u6570","text":"<ul> <li><code>targets</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(N,)</code>)      \u4e2d\u95f4\u503c\u6a21\u578b\u8f93\u51fa\u5e8f\u5217\uff08\u4f8b\u5982\uff1a<code>SBox[plaintext[i] ^ k_guess]</code>\uff09\uff0c\u957f\u5ea6\u4e3a <code>N</code>\uff0c\u5bf9\u5e94 <code>N</code> \u6761\u80fd\u91cf\u8ff9\u3002</li> <li><code>traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(N, T)</code>))      \u80fd\u91cf\u8ff9\u6570\u636e\uff0c\u5176\u4e2d\uff1a<ul> <li><code>N</code>\uff1a\u8ff9\u7684\u6570\u91cf\uff08\u5fc5\u987b\u4e0e <code>targets</code> \u957f\u5ea6\u4e00\u81f4\uff09</li> <li><code>T</code>\uff1a\u6bcf\u6761\u8ff9\u7684\u91c7\u6837\u70b9\u6570\u91cf</li> </ul> </li> </ul>"},{"location":"attack/#_2","title":"\u8fd4\u56de\u503c","text":"<ul> <li> <p><code>pearson_list</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(T,)</code>)      \u6bcf\u4e2a\u91c7\u6837\u70b9\u4e0e <code>targets</code> \u4e4b\u95f4\u7684\u76ae\u5c14\u900a\u76f8\u5173\u7cfb\u6570\u7684\u7edd\u5bf9\u503c\u6570\u7ec4\u3002      \u503c\u57df\u8303\u56f4\uff1a<code>[0, 1]</code></p> <ul> <li>\u63a5\u8fd1 <code>1</code>\uff1a\u5f3a\u76f8\u5173</li> <li>\u63a5\u8fd1 <code>0</code>\uff1a\u5f31\u76f8\u5173\u6216\u65e0\u76f8\u5173</li> </ul> <p>\u7528\u4e8e\u5b9a\u4f4d\u6700\u53ef\u80fd\u6cc4\u9732\u5bc6\u94a5\u4fe1\u606f\u7684\u91c7\u6837\u70b9\u3002</p> </li> </ul> <pre><code>import numpy as np\nfrom mlscat.utils import pcc\n\n# \u5047\u8bbe\u5df2\u6709\u6570\u636e\ntargets = np.array([123, 45, 89, 111, 67])  # 5 \u6761\u8ff9\u7684\u4e2d\u95f4\u503c\ntraces = np.random.rand(5, 1000)            # 5 \u6761\u8ff9\uff0c\u6bcf\u6761 1000 \u4e2a\u91c7\u6837\u70b9\n\n# \u8ba1\u7b97\u76f8\u5173\u7cfb\u6570\ncorrelations = pcc(targets, traces)\n\n# \u627e\u5230\u6700\u5927\u76f8\u5173\u70b9\nmax_corr_point = np.argmax(correlations)\nprint(\"\u6700\u76f8\u5173\u91c7\u6837\u70b9\u7d22\u5f15:\", max_corr_point)\nprint(\"\u76f8\u5173\u7cfb\u6570:\", correlations[max_corr_point])\n</code></pre>"},{"location":"leakage/","title":"\u6cc4\u9732\u6a21\u578b","text":"<p>\u901a\u5e38\uff0c\u6cc4\u9732\u6a21\u578b\u7684\u9009\u62e9\u5f80\u5f80\u4f1a\u6781\u5927\u7a0b\u5ea6\u4e0a\u5f71\u54cd\u540e\u7eed\u653b\u51fb\u7684\u7ed3\u679c\uff0c\u5177\u4f53\u6765\u8bb2\uff0c\u5f53\u6cc4\u9732\u6a21\u578b\u5bf9\u76ee\u6807\u4e2d\u95f4\u503c\u4fe1\u606f \u6cc4\u9732\u7279\u5f81\u523b\u753b\u7cbe\u5ea6\u8f83\u9ad8\u65f6\uff0c\u7531\u523b\u753b\u8bef\u5dee\u5e26\u6765\u7684\u566a\u58f0\u6c34\u5e73\u8f83\u4f4e\uff0c\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u80fd\u51cf\u5c11\u653b\u51fb\u4eba\u5458\u6210\u529f\u6062\u590d\u5bc6\u94a5\u9700\u8981\u7684\u80fd\u91cf\u8ff9\u6570\u76ee\u3002</p> <p>\u4e3a\u4e86\u7edf\u4e00\u4ee3\u7801\u98ce\u683c\uff0c\u6240\u6709\u6d89\u53ca\u8f6c\u6362\u7684\u65b9\u6cd5\u7684\u8f93\u5165\u5747\u4ee5\u6570\u7ec4\u7ea7\u8fdb\u884c\u64cd\u4f5c</p>"},{"location":"leakage/#hw-function","title":"HW function","text":"<pre><code>cat.leakage.hw(mid: list[int]) -&gt; list[int]\n</code></pre> <p>\u8fd4\u56de\u8f93\u5165\u4e2d\u95f4\u503c\u5bf9\u5e94\u7684\u6c49\u660e\u91cd\u91cf.</p> <p>\u53c2\u6570</p> <ul> <li>mid: \u8f93\u5165\u7684\u5341\u8fdb\u5236\u4e2d\u95f4\u503c\u6570\u7ec4</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; result = cat.leakage.hw([191, 221, 13, 16])\n&gt;&gt;&gt; result\n[7, 6, 3, 1]\n</code></pre>"},{"location":"leakage/#lsb-function","title":"lsb function !\u6682\u672a\u5b9e\u73b0","text":"<pre><code>cat.leakage.lsb(mid: list[int]) -&gt; list[int]\n</code></pre> <p>\u8fd4\u56de\u4e2d\u95f4\u503c\u7684\u6700\u4f4e\u4f4d</p>"},{"location":"metrics/","title":"\u8bc4\u4f30\u6307\u6807","text":""},{"location":"metrics/#calc_ge_sr","title":"calc_ge_sr","text":"<p>mlscat.metrics.calc_ge_sr(predictions, targets, num_traces, key, times=1000, interval=1)</p> <p>\u8ba1\u7b97\u5bc6\u94a5\u6062\u590d\u7684\u6210\u529f\u7387\uff08Success Rate, SR\uff09\u548c\u5e73\u5747\u6392\u540d\uff08Guessing Entropy, GE \u98ce\u683c\u6392\u540d\uff09\uff0c\u7528\u4e8e\u8bc4\u4f30\u4fa7\u4fe1\u9053\u653b\u51fb\uff08\u5982 CPA\u3001DPA\u3001\u6a21\u677f\u653b\u51fb\uff09\u7684\u6027\u80fd\u3002</p> <p>\u8be5\u51fd\u6570\u901a\u8fc7\u591a\u6b21\u968f\u673a\u91cd\u91c7\u6837\u653b\u51fb\u9884\u6d4b\u7ed3\u679c\uff0c\u7edf\u8ba1\u5728\u4e0d\u540c\u8ff9\u6570\u4e0b\u6b63\u786e\u5bc6\u94a5\u7684\u6392\u540d\u53d8\u5316\u548c\u6210\u529f\u6062\u590d\u6982\u7387\uff0c\u751f\u6210\u5e73\u6ed1\u7684\u8bc4\u4f30\u66f2\u7ebf\u3002</p> <pre><code>def calc_ge_sr(\n    predictions: list,\n    targets: np.ndarray,\n    num_traces: int,\n    key: int,\n    times: int = 1000,\n    interval: int = 1\n) -&gt; tuple:\n</code></pre> <p>\u8ba1\u7b97\u5bc6\u94a5\u6062\u590d\u7684\u6210\u529f\u7387\uff08Success Rate, SR\uff09\u548c\u5e73\u5747\u6392\u540d\uff08Guessing Entropy, GE \u98ce\u683c\u6392\u540d\uff09\uff0c\u7528\u4e8e\u8bc4\u4f30\u4fa7\u4fe1\u9053\u653b\u51fb\uff08\u5982 CPA\u3001DPA\u3001\u6a21\u677f\u653b\u51fb\uff09\u7684\u6027\u80fd\u3002</p> <p>\u8be5\u51fd\u6570\u901a\u8fc7\u591a\u6b21\u968f\u673a\u91cd\u91c7\u6837\u653b\u51fb\u9884\u6d4b\u7ed3\u679c\uff0c\u7edf\u8ba1\u5728\u4e0d\u540c\u8ff9\u6570\u4e0b\u6b63\u786e\u5bc6\u94a5\u7684\u6392\u540d\u53d8\u5316\u548c\u6210\u529f\u6062\u590d\u6982\u7387\uff0c\u751f\u6210\u5e73\u6ed1\u7684\u8bc4\u4f30\u66f2\u7ebf\u3002</p>"},{"location":"metrics/#_2","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li> <p><code>predictions</code> (<code>list</code> of <code>dict</code> or <code>list</code> of <code>np.ndarray</code>)      \u653b\u51fb\u8fc7\u7a0b\u4e2d\u6bcf\u6761\u8ff9\u7684\u9884\u6d4b\u6982\u7387\u8f93\u51fa\u5217\u8868\uff0c\u957f\u5ea6\u4e3a <code>N</code>\uff08\u8ff9\u603b\u6570\uff09\u3002      \u6bcf\u4e2a\u5143\u7d20\u5e94\u4e3a\uff1a</p> <ul> <li>\u5b57\u5178\uff1a<code>{\u4e2d\u95f4\u503c\u7c7b\u522b -&gt; \u6982\u7387}</code>\uff0c\u6216</li> <li>\u6570\u7ec4\uff1a\u957f\u5ea6\u4e3a 256 \u7684\u6982\u7387\u5411\u91cf\uff08\u7d22\u5f15\u4e3a\u5bc6\u94a5\u731c\u6d4b\uff09</li> </ul> <p>\u793a\u4f8b\uff1a<code>predictions[i][k]</code> \u8868\u793a\u7b2c <code>i</code> \u6761\u8ff9\u5728\u5bc6\u94a5\u731c\u6d4b <code>k</code> \u4e0b\u7684\u4f3c\u7136\u6216\u76f8\u5173\u503c\u3002</p> </li> <li> <p><code>targets</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(N, 256)</code>)      \u9884\u5148\u8ba1\u7b97\u7684\u6bcf\u6761\u8ff9\u5728\u6bcf\u4e2a\u5bc6\u94a5\u731c\u6d4b\u4e0b\u7684\u4e2d\u95f4\u503c\u7c7b\u522b\u6807\u7b7e\u3002      \u7528\u4e8e\u5c06 <code>predictions[i]</code> \u6620\u5c04\u5230\u5bf9\u5e94\u5bc6\u94a5\u731c\u6d4b\u7684\u6982\u7387\u3002      \u4f8b\u5982\uff1a<code>targets[i][k] = SBox(plaintext[i][byte] ^ k)</code></p> </li> <li> <p><code>num_traces</code> (<code>int</code>)      \u6bcf\u6b21\u5b9e\u9a8c\u4e2d\u7528\u4e8e\u653b\u51fb\u7684\u6700\u5927\u8ff9\u6570\u3002\u7ed3\u679c\u5c06\u6309 <code>interval</code> \u95f4\u9694\u5206\u6bb5\u7edf\u8ba1\u3002</p> </li> <li> <p><code>key</code> (<code>int</code>)      \u5b9e\u9645\u6b63\u786e\u7684\u5bc6\u94a5\u5b57\u8282\u503c\uff080\u2013255\uff09\uff0c\u7528\u4e8e\u8ba1\u7b97\u5176\u5728\u5019\u9009\u5217\u8868\u4e2d\u7684\u6392\u540d\u548c\u662f\u5426\u6210\u529f\u6062\u590d\u3002</p> </li> <li> <p><code>times</code> (<code>int</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>1000</code>)      \u91cd\u590d\u5b9e\u9a8c\u7684\u6b21\u6570\uff08\u8499\u7279\u5361\u6d1b\u6a21\u62df\uff09\uff0c\u7528\u4e8e\u5e73\u5747\u968f\u673a\u6027\u5f71\u54cd\uff0c\u63d0\u9ad8\u8bc4\u4f30\u7a33\u5b9a\u6027\u3002</p> </li> <li> <p><code>interval</code> (<code>int</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>1</code>)      \u7edf\u8ba1\u7ed3\u679c\u7684\u65f6\u95f4\u95f4\u9694\u3002\u4f8b\u5982 <code>interval=5</code> \u8868\u793a\u6bcf 5 \u6761\u8ff9\u62a5\u544a\u4e00\u6b21\u6210\u529f\u7387\u548c\u6392\u540d\u3002</p> <p>\u8f93\u51fa\u70b9\u6570\u4e3a\uff1a<code>n_i = num_traces // interval</code></p> </li> </ul>"},{"location":"metrics/#_3","title":"\u8fd4\u56de\u503c","text":"<p>\u8fd4\u56de\u4e00\u4e2a\u5305\u542b\u4e24\u4e2a\u6570\u7ec4\u7684\u5143\u7ec4\uff1a</p> <ul> <li><code>success_rate</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(n_i,)</code>)      \u6bcf\u4e2a\u95f4\u9694\u70b9\u4e0a\u7684\u5e73\u5747\u6210\u529f\u7387\u3002      <code>success_rate[i]</code> \u8868\u793a\u4f7f\u7528\u524d <code>(i+1)*interval</code> \u6761\u8ff9\u65f6\uff0c\u6b63\u786e\u5bc6\u94a5\u6392\u5728\u7b2c\u4e00\u540d\u7684\u6982\u7387\uff08\u5373 <code>rank &lt; 1</code>\uff0c\u56e0\u4e3a\u7d22\u5f15\u4ece 0 \u5f00\u59cb\uff09\u3002</li> <li><code>all_keys_rank</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(n_i,)</code>)      \u6bcf\u4e2a\u95f4\u9694\u70b9\u4e0a\u7684\u5e73\u5747\u5bc6\u94a5\u6392\u540d\uff08Guessing Entropy \u98ce\u683c\uff09\u3002      <code>all_keys_rank[i]</code> \u8868\u793a\u4f7f\u7528\u524d <code>(i+1)*interval</code> \u6761\u8ff9\u540e\uff0c\u6b63\u786e\u5bc6\u94a5\u7684\u5e73\u5747\u6392\u540d\uff08\u8d8a\u4f4e\u8d8a\u597d\uff09\u3002</li> </ul> <p>\u26a0\ufe0f \u6ce8\u610f\uff1a\u8fd4\u56de\u503c\u5df2\u9664\u4ee5 <code>times</code>\uff0c\u5373\u4e3a\u5e73\u5747\u503c\u3002</p> <p>\u98df\u7528\u65b9\u6cd5</p> <pre><code>sr, rank = calc_ge_sr(\n    predictions=predictions,\n    targets=targets,    // you know how to calculate this array, right?\n    num_traces=100,\n    key=true_key,\n    times=100,\n    interval=5\n)\n</code></pre>"},{"location":"metrics/#add_gaussian_noise","title":"add_gaussian_noise","text":"<p>mlscat.preprocessing.add_gaussian_noise(traces, std, mean=0)</p> <p>\u4e3a\u80fd\u91cf\u8ff9\u6570\u636e\u6dfb\u52a0\u9ad8\u65af\u767d\u566a\u58f0\uff08Additive White Gaussian Noise, AWGN\uff09\uff0c\u7528\u4e8e\uff1a - \u6a21\u62df\u771f\u5b9e\u6d4b\u91cf\u73af\u5883\u4e2d\u7684\u566a\u58f0\u5e72\u6270 - \u589e\u5f3a\u8bad\u7ec3\u6570\u636e\u7684\u9c81\u68d2\u6027\uff08\u6570\u636e\u589e\u5f3a\uff09 - \u8bc4\u4f30\u5bc6\u7801\u8bbe\u5907\u6216\u653b\u51fb\u7b97\u6cd5\u5728\u4f4e\u4fe1\u566a\u6bd4\u4e0b\u7684\u8868\u73b0</p> <p>\u8be5\u51fd\u6570\u5bf9\u6bcf\u6761\u8ff9\u72ec\u7acb\u6dfb\u52a0\u5747\u503c\u4e3a <code>mean</code>\u3001\u6807\u51c6\u5dee\u4e3a <code>std</code> \u7684\u6b63\u6001\u5206\u5e03\u566a\u58f0\u3002</p>"},{"location":"metrics/#_4","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li> <p><code>traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(m, n)</code> \u6216 <code>(m,)</code>)      \u539f\u59cb\u529f\u7387\u8ff9\u6570\u7ec4\uff0c\u652f\u6301\uff1a</p> <ul> <li>\u4e8c\u7ef4\uff1a<code>(m, n)</code> \u2014 <code>m</code> \u6761\u8ff9\uff0c\u6bcf\u6761 <code>n</code> \u4e2a\u91c7\u6837\u70b9</li> <li>\u4e00\u7ef4\uff1a<code>(n,)</code> \u2014 \u5355\u6761\u8ff9</li> </ul> <p>\u6570\u636e\u7c7b\u578b\u4e0d\u9650\uff0c\u8f93\u51fa\u5c06\u4fdd\u7559\u539f\u59cb\u8bed\u4e49\u3002</p> </li> <li> <p><code>std</code> (<code>float</code>)      \u566a\u58f0\u7684\u6807\u51c6\u5dee\uff08Standard Deviation\uff09\uff0c\u63a7\u5236\u566a\u58f0\u5f3a\u5ea6\u6216\u201c\u566a\u58f0\u6c34\u5e73\u201d\u3002</p> <ul> <li><code>std = 0</code>\uff1a\u65e0\u566a\u58f0\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e</li> <li><code>std</code> \u8d8a\u5927\uff0c\u6dfb\u52a0\u7684\u566a\u58f0\u8d8a\u5f3a\uff0c\u4fe1\u566a\u6bd4\uff08SNR\uff09\u8d8a\u4f4e</li> <li>\u793a\u4f8b\u5efa\u8bae\u503c\uff1a<ul> <li>\u8f7b\u5ea6\u566a\u58f0\uff1a<code>std = 0.1 * np.std(traces)</code></li> <li>\u4e2d\u5ea6\u566a\u58f0\uff1a<code>std = 0.3 * np.std(traces)</code></li> <li>\u5f3a\u566a\u58f0\uff1a<code>std = 0.5 * np.std(traces)</code></li> </ul> </li> </ul> </li> <li> <p><code>mean</code> (<code>float</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>0</code>)      \u566a\u58f0\u7684\u5747\u503c\u3002\u901a\u5e38\u8bbe\u4e3a <code>0</code> \u8868\u793a\u5bf9\u79f0\u6270\u52a8\u3002\u82e5\u8bbe\u5907\u5b58\u5728\u7cfb\u7edf\u6027\u504f\u79fb\uff0c\u53ef\u8bbe\u4e3a\u975e\u96f6\u503c\u3002</p> </li> </ul>"},{"location":"metrics/#_5","title":"\u8fd4\u56de\u503c","text":"<ul> <li><code>noise_traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6\u4e0e\u8f93\u5165 <code>traces</code> \u76f8\u540c)</li> </ul> <pre><code>import numpy as np\nfrom mlscat.security import add_gaussian_noise\n\n# \u521b\u5efa\u6a21\u62df\u8ff9\u6570\u636e (3 \u6761\u8ff9\uff0c\u6bcf\u6761 1000 \u4e2a\u70b9)\noriginal_traces = np.array([\n    2 * np.sin(2 * np.pi * 0.02 * np.arange(1000)) + \n    0.5 * np.sin(2 * np.pi * 0.05 * np.arange(1000))\n    for _ in range(3)\n])  # shape: (3, 1000)\n\n# \u6dfb\u52a0\u9ad8\u65af\u566a\u58f0\uff1a\u5747\u503c0\uff0c\u6807\u51c6\u5dee0.3\nnoisy_traces = add_gaussian_noise(traces=original_traces, std=0.3, mean=0)\n</code></pre>"},{"location":"metrics/#shuffling","title":"shuffling","text":"<p>mlscat.preprocessing.shuffling(traces, times)</p> <p>\u5bf9\u6bcf\u6761\u529f\u7387\u8ff9\u8fdb\u884c\u968f\u673a\u70b9\u4ea4\u6362\uff08Random Point Swapping\uff09\uff0c\u6a21\u62df\u786c\u4ef6\u6216\u8f6f\u4ef6\u4e2d\u5b9e\u73b0\u7684\u201c\u968f\u673a\u91cd\u6392\u9632\u62a4\u201d\uff08Random Instruction Shuffling\uff09\u673a\u5236\u3002</p> <p>\u8be5\u51fd\u6570\u5728\u6bcf\u6761\u8ff9\u5185\u90e8\u968f\u673a\u9009\u62e9\u4e24\u4e2a\u91c7\u6837\u70b9\u5e76\u4ea4\u6362\u5176\u503c\uff0c\u91cd\u590d <code>times</code> \u6b21\uff0c\u4ece\u800c\u6270\u4e71\u529f\u7387\u8ff9\u7684\u65f6\u95f4\u987a\u5e8f\uff0c\u589e\u52a0\u4fa7\u4fe1\u9053\u653b\u51fb\u96be\u5ea6\u3002</p> <p>\u26a0\ufe0f \u6ce8\u610f\uff1a\u6b64\u65b9\u6cd5\u4ec5\u7528\u4e8e\u6a21\u62df\u8f6f\u4ef6/\u6307\u4ee4\u7ea7\u968f\u673a\u91cd\u6392\u5bf9\u80fd\u91cf\u8ff9\u7684\u5f71\u54cd\uff0c\u4e0d\u6539\u53d8\u539f\u59cb\u6570\u636e\u8bed\u4e49\uff0c\u4f46\u4f1a\u7834\u574f\u65f6\u95f4\u76f8\u5173\u6027\u3002</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Mlscat \u5feb\u901f\u4e0a\u624b\u6307\u5357</p> <p>First of all</p> <pre><code>import mlscat as cat\n</code></pre>"},{"location":"quickstart/#_1","title":"\u83b7\u53d6\u4e2d\u95f4\u503c","text":"<p>\u82e5\u8981\u76f4\u63a5\u83b7\u53d6\u4e2d\u95f4\u503c\uff0c\u5206\u4e3a\u5df2\u77e5\u63a9\u7801\u4ee5\u53ca\u672a\u77e5\u63a9\u7801\u4e24\u79cd\u60c5\u51b5\u3002</p> <pre><code># \u63a9\u7801\u672a\u77e5\n\n\n</code></pre>"},{"location":"quickstart/#cpa","title":"CPA","text":"<p>\u82e5\u8981\u5c1d\u8bd5\u4f7f\u7528Mlscat\u8fdb\u884c\u4e00\u6b21CPA\u653b\u51fb\uff0c\u4ec5\u9700\u901a\u8fc7\u4ee5\u4e0b\u51e0\u884c\u4ee3\u7801\u3002</p> <p>\u5047\u8bbe\u653b\u51fb\u7684\u5bc6\u94a5\u5b57\u8282<code>byte_num</code>\u4e3a<code>2</code>\uff0c</p> <pre><code># \u63a9\u7801\u672a\u77e5\n\n# plaintexts.shape=[m,16]    AES-128\n# traces.shape = [m,n] \n\nbyte_num = 2\ncpa(byte_num, plaintexts, traces)\n</code></pre>"},{"location":"security/","title":"\u9632\u62a4\u63aa\u65bd","text":""},{"location":"security/#desynchronization","title":"Desynchronization","text":"<p>mlscat.security.desynchronization(traces, window)</p> <p>\u5bf9\u529f\u7387\u8ff9\u6570\u636e\u65bd\u52a0\u968f\u673a\u53bb\u540c\u6b65\u5316\uff08Random Desynchronization\uff09\uff0c\u7528\u4e8e\u6a21\u62df\u6216\u589e\u5f3a\u5bf9\u6297\u5b9e\u9645\u73af\u5883\u4e2d\u56e0\u65f6\u95f4\u6296\u52a8\u3001\u9632\u62a4\u673a\u5236\uff08\u5982\u968f\u673a\u5ef6\u8fdf\uff09\u5f15\u8d77\u7684\u4fe1\u53f7\u504f\u79fb\u3002</p> <p>\u8be5\u51fd\u6570\u4e3a\u6bcf\u6761\u8ff9\u5f15\u5165\u4e00\u4e2a\u5728 <code>[0, window]</code> \u8303\u56f4\u5185\u7684\u968f\u673a\u5ef6\u8fdf\uff0c\u5728\u65f6\u95f4\u8f74\u4e0a\u5411\u53f3\u79fb\u52a8\u4fe1\u53f7\uff0c\u5e76\u4f7f\u7528\u96f6\u586b\u5145\uff08zero-padding\uff09\u5904\u7406\u79fb\u4f4d\u540e\u7a7a\u51fa\u7684\u90e8\u5206\u3002</p>"},{"location":"security/#_2","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li> <p><code>traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(m, n)</code>)      \u539f\u59cb\u4e8c\u7ef4\u529f\u7387\u8ff9\u6570\u7ec4\uff0c\u5176\u4e2d\uff1a</p> <ul> <li><code>m</code>\uff1a\u8ff9\u7684\u6570\u91cf</li> <li><code>n</code>\uff1a\u6bcf\u6761\u8ff9\u7684\u91c7\u6837\u70b9\u6570</li> </ul> <p>\u793a\u4f8b\uff1a<code>traces[i]</code> \u8868\u793a\u7b2c <code>i</code> \u6761\u529f\u7387\u8ff9\u3002</p> </li> <li> <p><code>window</code> (<code>int</code>)      \u53bb\u540c\u6b65\u5316\u7684\u6700\u5927\u5ef6\u8fdf\u8303\u56f4\uff08\u4ee5\u91c7\u6837\u70b9\u4e3a\u5355\u4f4d\uff09\u3002\u6bcf\u6761\u8ff9\u5c06\u88ab\u968f\u673a\u5ef6\u8fdf <code>0</code> \u5230 <code>window</code> \u4e2a\u70b9\uff08\u542b\uff09\u3002</p> <ul> <li>\u82e5 <code>window = 0</code>\uff1a\u65e0\u5ef6\u8fdf\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e\u3002</li> <li>\u63a8\u8350\u503c\uff1a\u6839\u636e\u91c7\u6837\u7387\u548c\u7cfb\u7edf\u65f6\u949f\u6ce2\u52a8\u4f30\u8ba1\uff08\u5982 1\u201310 \u4e2a\u70b9\uff09\u3002</li> </ul> </li> </ul>"},{"location":"security/#_3","title":"\u8fd4\u56de\u503c","text":"<ul> <li> <p><code>delay_traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(m, n)</code>)      \u7ecf\u8fc7\u53bb\u540c\u6b65\u5316\u5904\u7406\u540e\u7684\u8ff9\u6570\u7ec4\u3002\u6bcf\u6761\u8ff9\u5411\u53f3\u79fb\u52a8 <code>random_num \u2208 [0, window]</code> \u4e2a\u70b9\uff0c\u5de6\u4fa7\u8865 <code>random_num</code> \u4e2a <code>0</code>\u3002</p> <p>\u26a0\ufe0f \u6ce8\u610f\uff1a\u7531\u4e8e\u4f7f\u7528\u96f6\u586b\u5145\uff0c\u79fb\u4f4d\u540e\u8ff9\u7684\u8d77\u59cb\u90e8\u5206\u4f1a\u5f15\u5165 <code>0</code> \u503c\uff0c\u6682\u65f6\u4e0d\u77e5\u9053\u5982\u4f55\u4f18\u5316</p> </li> </ul> <pre><code>import numpy as np\nfrom mlscat.security import desynchronization\n\n# \u521b\u5efa\u6a21\u62df\u8ff9\u6570\u636e (5 \u6761\u8ff9\uff0c\u6bcf\u6761 100 \u4e2a\u91c7\u6837\u70b9)\noriginal_traces = np.array([\n    np.sin(np.linspace(0, 4*np.pi, 100)) + 0.1*np.random.randn(100) \n    for _ in range(5)\n])  # shape: (5, 100)\n\n# \u65bd\u52a0\u53bb\u540c\u6b65\u5316\uff0c\u6700\u5927\u5ef6\u8fdf\u4e3a 5 \u4e2a\u91c7\u6837\u70b9\ndesync_traces = desynchronization(traces=original_traces, window=5)\n</code></pre>"},{"location":"security/#shuffling","title":"shuffling","text":"<p>mlscat.preprocessing.shuffling(traces, times)</p> <p>\u5bf9\u6bcf\u6761\u80fd\u91cf\u8ff9\u8fdb\u884c\u968f\u673a\u70b9\u4ea4\u6362\uff08Random Point Swapping\uff09\uff0c\u6a21\u62df\u786c\u4ef6\u6216\u8f6f\u4ef6\u4e2d\u5b9e\u73b0\u7684\u201c\u968f\u673a\u91cd\u6392\u9632\u62a4\u201d\uff08Random Instruction Shuffling\uff09\u673a\u5236\u3002</p> <p>\u8be5\u51fd\u6570\u5728\u6bcf\u6761\u8ff9\u5185\u90e8\u968f\u673a\u9009\u62e9\u4e24\u4e2a\u91c7\u6837\u70b9\u5e76\u4ea4\u6362\u5176\u503c\uff0c\u91cd\u590d <code>times</code> \u6b21\uff0c\u4ece\u800c\u6270\u4e71\u529f\u7387\u8ff9\u7684\u65f6\u95f4\u987a\u5e8f\uff0c\u589e\u52a0\u4fa7\u4fe1\u9053\u653b\u51fb\u96be\u5ea6</p>"},{"location":"security/#_4","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li> <p><code>traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(m, n)</code> \u6216 <code>(n,)</code>)      \u539f\u59cb\u80fd\u91cf\u8ff9\u6570\u7ec4\uff1a</p> <ul> <li>\u4e8c\u7ef4\uff1a<code>(m, n)</code> \u2014 <code>m</code> \u6761\u80fd\u91cf\u8ff9\uff0c\u6bcf\u6761 <code>n</code> \u4e2a\u91c7\u6837\u70b9</li> <li>\u4e00\u7ef4\uff1a<code>(n,)</code> \u2014 \u5355\u6761\u80fd\u91cf\u8ff9</li> </ul> <p>\u793a\u4f8b\uff1a<code>traces[i][t]</code> \u8868\u793a\u7b2c <code>i</code> \u6761\u80fd\u91cf\u8ff9\u5728\u65f6\u95f4\u70b9 <code>t</code> \u7684\u529f\u8017\u503c\u3002</p> </li> <li> <p><code>times</code> (<code>int</code>)      \u6bcf\u6761\u80fd\u91cf\u8ff9\u6267\u884c\u968f\u673a\u4ea4\u6362\u7684\u6b21\u6570\u3002</p> <ul> <li><code>times = 0</code>\uff1a\u65e0\u4ea4\u6362\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e</li> <li><code>times</code> \u8d8a\u5927\uff0c\u91cd\u6392\u7a0b\u5ea6\u8d8a\u9ad8\uff0c\u65f6\u95f4\u7ed3\u6784\u7834\u574f\u8d8a\u4e25\u91cd</li> <li>\u63a8\u8350\u503c\uff1a<code>10 ~ 100</code>\uff08\u6839\u636e\u80fd\u91cf\u8ff9\u957f\u5ea6\u8c03\u6574\uff09</li> </ul> <p>\ud83d\udca1 \u63d0\u793a\uff1a\u901a\u5e38 <code>times</code> \u4e0e\u8ff9\u957f\u5ea6 <code>n</code> \u6210\u6b63\u6bd4\uff08\u5982 <code>times = n // 10</code>\uff09</p> </li> </ul>"},{"location":"security/#_5","title":"\u8fd4\u56de\u503c","text":"<ul> <li><code>shuffled_traces</code> (<code>numpy.ndarray</code>, \u5f62\u72b6\u4e0e\u8f93\u5165 <code>traces</code> \u76f8\u540c)     \u7ecf\u8fc7 <code>times</code> \u6b21\u968f\u673a\u4ea4\u6362\u540e\u7684\u529f\u7387\u8ff9\u6570\u636e\u3002     \u6bcf\u6761\u8ff9\u72ec\u7acb\u8fdb\u884c\u91cd\u6392\uff0c\u80fd\u91cf\u8ff9\u4e4b\u95f4\u4e0d\u4ea4\u53c9\u3002</li> </ul> <pre><code>import numpy as np\nfrom mlscat.preprocessing import shuffling\n\n# \u521b\u5efa\u6a21\u62df\u80fd\u91cf\u8ff9\u6570\u636e (2 \u6761\u8ff9\uff0c\u6bcf\u6761 200 \u4e2a\u70b9)\noriginal_traces = np.array([\n    np.sin(0.1 * np.arange(200)) + 0.5 * np.random.rand(200),\n    np.cos(0.1 * np.arange(200)) + 0.3 * np.random.rand(200)\n])  # shape: (2, 200)\n\n# \u5e94\u7528\u968f\u673a\u91cd\u6392\uff1a\u6bcf\u6761\u80fd\u91cf\u8ff9\u4ea4\u6362 30 \u6b21\nshuffled_traces = shuffling(traces=original_traces, times=30)\n</code></pre>"},{"location":"utils/","title":"\u5176\u4ed6\u5de5\u5177","text":""},{"location":"utils/#get_mid","title":"get_mid","text":"<p>mlscat.utils.get_mid(p, k, mask_scheme=None)</p> <p>\u8ba1\u7b97\u52a0\u5bc6\u8fc7\u7a0b\u4e2d\u67d0\u4e2a\u5b57\u8282\u7684\u4e2d\u95f4\u503c\uff08Intermediate Value\uff09\uff0c\u652f\u6301\u65e0\u63a9\u7801\u548c\u5e03\u5c14\u63a9\u7801\uff08Boolean Masking\uff09\u4e24\u79cd\u6a21\u5f0f\uff0c\u5e38\u7528\u4e8e\u4fa7\u4fe1\u9053\u5206\u6790\u4e2d\u7684\u6a21\u677f\u6784\u5efa\u6216\u653b\u51fb\u9636\u6bb5\u6807\u7b7e\u751f\u6210\u3002</p> <p>\u8be5\u51fd\u6570\u6a21\u62df AES \u52a0\u5bc6\u4e2d <code>SBox[plaintext ^ key]</code> \u64cd\u4f5c\uff0c\u5e76\u53ef\u6269\u5c55\u652f\u6301\u63a9\u7801\u9632\u62a4\u4e0b\u7684\u4e2d\u95f4\u503c\u8ba1\u7b97\u3002</p>"},{"location":"utils/#_2","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li><code>p</code> (<code>int</code>)      \u660e\u6587\u5b57\u8282\uff088 \u4f4d\uff0c\u8303\u56f4 <code>0x00</code> ~ <code>0xFF</code>\uff09\u3002</li> <li><code>k</code> (<code>int</code>)      \u5bc6\u94a5\u731c\u6d4b\u5b57\u8282\uff088 \u4f4d\uff0c\u8303\u56f4 <code>0x00</code> ~ <code>0xFF</code>\uff09\u3002</li> <li><code>mask</code> (<code>int</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>-1</code>)      \u63a9\u7801\u503c\uff1a<ul> <li>\u82e5\u4e3a <code>-1</code>\uff1a\u8868\u793a\u65e0\u63a9\u7801\u6a21\u5f0f\uff0c\u4ec5\u8ba1\u7b97 <code>SBox[p ^ k]</code></li> <li>\u82e5\u4e3a\u5176\u4ed6\u503c\uff08\u5982 <code>0x5A</code>\uff09\uff1a\u8868\u793a\u4f7f\u7528\u7684\u63a9\u7801\u5b57\u8282\uff0c\u9700\u914d\u5408 <code>mask_scheme</code> \u4f7f\u7528</li> </ul> </li> <li><code>mask_scheme</code> (<code>str</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>None</code>)      \u63a9\u7801\u65b9\u6848\u7c7b\u578b\uff1a<ul> <li><code>None</code> \u6216\u672a\u6307\u5b9a\uff1a\u4f7f\u7528\u65e0\u63a9\u7801\u8def\u5f84</li> <li><code>'bool'</code>\uff1a\u542f\u7528\u5e03\u5c14\u63a9\u7801\uff08Boolean Masking\uff09\uff0c\u8fd4\u56de <code>SBox[p ^ k] ^ mask</code></li> <li>\u5176\u4ed6\u503c\uff1a\u5f53\u524d\u672a\u5b9e\u73b0\uff0c\u5ffd\u7565</li> </ul> </li> </ul>"},{"location":"utils/#_3","title":"\u8fd4\u56de\u503c","text":"<ul> <li> <p><code>int</code></p> <p>\u8ba1\u7b97\u5f97\u5230\u7684\u4e2d\u95f4\u503c\u5b57\u8282\uff0c\u8303\u56f4 0x00~0xFF\uff0c\u5177\u4f53\u5982\u4e0b\uff1a</p> <ul> <li>\u65e0\u63a9\u7801\u65f6\uff1a<code>AES_Sbox[p ^ k]</code></li> <li>\u5e03\u5c14\u63a9\u7801\u65f6\uff1a<code>AES_Sbox[p ^ k] ^ mask</code></li> </ul> </li> </ul> <pre><code>from mlscat.utils import get_mid\n\n# \u65e0\u63a9\u7801\u60c5\u51b5\np, k = 0x32, 0x2B\nmid_unmasked = get_mid(p, k)\n\n# \u5e03\u5c14\u63a9\u7801\u60c5\u51b5\nmask = 0x5A\nmid_masked = get_mid(p, k, mask=mask, mask_scheme='bool')\n</code></pre>"},{"location":"utils/#get_tatgets","title":"get_tatgets","text":"<p>mlscat.utils.get_targets(plaintexts, mask=-1)</p> <p>\u751f\u6210\u4e2d\u95f4\u503c\u6807\u7b7e\u77e9\u9635\uff08Targets Matrix\uff09\uff0c\u7528\u4e8e\u4fa7\u4fe1\u9053\u5206\u6790\u4e2d\u7684\u6a21\u677f\u6784\u5efa\u3001CPA\u3001DPA \u6216\u673a\u5668\u5b66\u4e60\u653b\u51fb\u3002</p> <p>\u8be5\u51fd\u6570\u4e3a\u6bcf\u6761\u660e\u6587\u548c\u6bcf\u4e2a\u53ef\u80fd\u7684\u5bc6\u94a5\u5b57\u8282\uff080\u2013255\uff09\u8ba1\u7b97\u5bf9\u5e94\u7684\u4e2d\u95f4\u503c\uff08\u5982 <code>SBox[plaintext ^ key]</code>\uff09\uff0c\u8f93\u51fa\u5f62\u72b6\u4e3a <code>(N, 256)</code> \u7684\u4e8c\u7ef4\u6570\u7ec4\uff0c\u5176\u4e2d\u6bcf\u4e00\u884c\u8868\u793a\u8be5\u8ff9\u5728 256 \u4e2a\u5bc6\u94a5\u731c\u6d4b\u4e0b\u7684\u4e2d\u95f4\u503c\u7c7b\u522b\u3002</p> <p>\u652f\u6301\u65e0\u63a9\u7801\u548c\u5e03\u5c14\u63a9\u7801\uff08Boolean Masking\uff09\u4e24\u79cd\u6a21\u5f0f\u3002</p>"},{"location":"utils/#_4","title":"\u53c2\u6570\u8bf4\u660e","text":"<ul> <li><code>plaintexts</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(N, 1)</code> \u6216 <code>(N,)</code>)      \u660e\u6587\u6570\u636e\u6570\u7ec4\uff0c\u5305\u542b <code>N</code> \u6761\u660e\u6587\u3002<ul> <li>\u6bcf\u4e2a\u5143\u7d20\u4e3a\u4e00\u4e2a\u5b57\u8282\uff08<code>0x00</code> ~ <code>0xFF</code>\uff09</li> <li>\u793a\u4f8b\uff1a<code>plaintexts[i][0]</code> \u8868\u793a\u7b2c <code>i</code> \u6761\u8ff9\u7684\u660e\u6587\u5b57\u8282</li> </ul> </li> <li><code>mask</code> (<code>int</code> \u6216 <code>numpy.ndarray</code>, \u53ef\u9009, \u9ed8\u8ba4: <code>-1</code>)      \u63a9\u7801\u63a7\u5236\u53c2\u6570\uff1a<ul> <li>\u82e5 <code>mask == -1</code> \u6216\u4e3a\u6574\u6570\uff1a\u8868\u793a\u65e0\u63a9\u7801\u6a21\u5f0f\uff0c\u4ec5\u8ba1\u7b97 <code>SBox[plaintext ^ key]</code></li> <li>\u82e5 <code>mask</code> \u662f\u957f\u5ea6\u4e3a <code>N</code> \u7684\u4e00\u7ef4\u6570\u7ec4\uff08\u5982 <code>np.ndarray</code>, shape: <code>(N,)</code>\uff09\uff1a\u8868\u793a\u6bcf\u6761\u8ff9\u4f7f\u7528\u7684\u5e03\u5c14\u63a9\u7801\u503c\uff0c\u8fd4\u56de <code>SBox[plaintext ^ key] ^ mask[i]</code></li> </ul> </li> </ul>"},{"location":"utils/#_5","title":"\u8fd4\u56de\u503c","text":"<ul> <li> <p><code>targets</code> (<code>numpy.ndarray</code>, \u5f62\u72b6: <code>(N, 256)</code>, \u7c7b\u578b: <code>int64</code>)      \u4e2d\u95f4\u503c\u6807\u7b7e\u77e9\u9635\uff0c\u7528\u4e8e\u540e\u7eed\u653b\u51fb\uff1a</p> <ul> <li><code>targets[i][k]</code> \u8868\u793a\u5728\u7b2c <code>i</code> \u6761\u80fd\u91cf\u8ff9\u3001\u5bc6\u94a5\u731c\u6d4b\u4e3a <code>k</code> \u65f6\uff0cS \u76d2\u8f93\u51fa\u7684\u4e2d\u95f4\u503c\uff08\u6216\u5176\u63a9\u7801\u540e\u503c\uff09</li> <li>\u53ef\u4f5c\u4e3a <code>TemplateAttack</code>\u3001<code>CPA</code> \u7b49\u7b97\u6cd5\u7684\u8f93\u5165\u6807\u7b7e</li> </ul> </li> </ul> <pre><code>import numpy as np\nfrom mlscat.utils import get_targets\n\n# \u5047\u8bbe\u5df2\u6709\u660e\u6587\u6570\u636e\nplaintexts = np.array([[0x32], [0x45], [0x98], [0x12]]) \n\n# \u60c5\u51b51\uff1a\u65e0\u63a9\u7801\ntargets_unmasked = get_targets(plaintexts)\nprint(\"Unmasked targets shape:\", targets_unmasked.shape)  \nprint(\"First row (key=0~5):\", targets_unmasked[0][:6])   \n\n# \u60c5\u51b52\uff1a\u5e26\u5e03\u5c14\u63a9\u7801\uff08\u6bcf\u6761\u80fd\u91cf\u8ff9\u4e00\u4e2a\u63a9\u7801\uff09\nmasks = np.array([0x5A, 0x3F, 0x11, 0x7E])  \ntargets_masked = get_targets(plaintexts, mask=masks)\nprint(\"Masked targets shape:\", targets_masked.shape)     \nprint(\"Masked first row:\", targets_masked[0][:6])        \n</code></pre>"},{"location":"%E6%9D%82%E9%A1%B9/","title":"\u6742\u9879","text":"<p>\u65b0\u7248\u672c\u7684tf\u7528one_cycle_lr\u4f1a\u62a5\u9519\uff0c\u4fee\u6539\u5982\u4e0b\uff1a</p> <pre><code>class OneCycleLR(Callback):\n    def __init__(self,\n                 num_samples,\n                 batch_size,\n                 max_lr,\n                 end_percentage=0.1,\n                 scale_percentage=None,\n                 maximum_momentum=0.95,\n                 minimum_momentum=0.85,\n                 verbose=True):\n        \"\"\" This callback implements a cyclical learning rate policy (CLR).\n        This is a special case of Cyclic Learning Rates, where we have only 1 cycle.\n        After the completion of 1 cycle, the learning rate will decrease rapidly to\n        100th its initial lowest value.\n\n        # Arguments:\n            num_samples: Integer. Number of samples in the dataset.\n            batch_size: Integer. Batch size during training.\n            max_lr: Float. Initial learning rate. This also sets the\n                starting learning rate (which will be 10x smaller than\n                this), and will increase to this value during the first cycle.\n            end_percentage: Float. The percentage of all the epochs of training\n                that will be dedicated to sharply decreasing the learning\n                rate after the completion of 1 cycle. Must be between 0 and 1.\n            scale_percentage: Float or None. If float, must be between 0 and 1.\n                If None, it will compute the scale_percentage automatically\n                based on the `end_percentage`.\n            maximum_momentum: Optional. Sets the maximum momentum (initial)\n                value, which gradually drops to its lowest value in half-cycle,\n                then gradually increases again to stay constant at this max value.\n                Can only be used with SGD Optimizer.\n            minimum_momentum: Optional. Sets the minimum momentum at the end of\n                the half-cycle. Can only be used with SGD Optimizer.\n            verbose: Bool. Whether to print the current learning rate after every\n                epoch.\n\n        # Reference\n            - [A disciplined approach to neural network hyper-parameters: Part 1 -- learning rate, batch size, weight_decay, and weight decay](https://arxiv.org/abs/1803.09820)\n            - [Super-Convergence: Very Fast Training of Residual Networks Using Large Learning Rates](https://arxiv.org/abs/1708.07120)\n        \"\"\"\n        super(OneCycleLR, self).__init__()\n\n        if end_percentage &lt; 0. or end_percentage &gt; 1.:\n            raise ValueError(\"`end_percentage` must be between 0 and 1\")\n\n        if scale_percentage is not None and (scale_percentage &lt; 0. or scale_percentage &gt; 1.):\n            raise ValueError(\"`scale_percentage` must be between 0 and 1\")\n\n        self.initial_lr = max_lr\n        self.end_percentage = end_percentage\n        self.scale = float(scale_percentage) if scale_percentage is not None else float(end_percentage)\n        self.max_momentum = maximum_momentum\n        self.min_momentum = minimum_momentum\n        self.verbose = verbose\n\n        if self.max_momentum is not None and self.min_momentum is not None:\n            self._update_momentum = True\n        else:\n            self._update_momentum = False\n\n        self.clr_iterations = 0.\n        self.history = {}\n\n        self.epochs = None\n        self.batch_size = batch_size\n        self.samples = num_samples\n        self.steps = None\n        self.num_iterations = None\n        self.mid_cycle_id = None\n\n    def _reset(self):\n        \"\"\"\n        Reset the callback.\n        \"\"\"\n        self.clr_iterations = 0.\n        self.history = {}\n\n    def compute_lr(self):\n        \"\"\"\n        Compute the learning rate based on which phase of the cycle it is in.\n\n        - If in the first half of training, the learning rate gradually increases.\n        - If in the second half of training, the learning rate gradually decreases.\n        - If in the final `end_percentage` portion of training, the learning rate\n            is quickly reduced to near 100th of the original min learning rate.\n\n        # Returns:\n            the new learning rate\n        \"\"\"\n        if self.clr_iterations &gt; 2 * self.mid_cycle_id:\n            current_percentage = (self.clr_iterations - 2 * self.mid_cycle_id)\n            current_percentage /= float((self.num_iterations - 2 * self.mid_cycle_id))\n            new_lr = self.initial_lr * (1. + (current_percentage *\n                                              (1. - 100.) / 100.)) * self.scale\n\n        elif self.clr_iterations &gt; self.mid_cycle_id:\n            current_percentage = 1. - (\n                    self.clr_iterations - self.mid_cycle_id) / self.mid_cycle_id\n            new_lr = self.initial_lr * (1. + current_percentage *\n                                        (self.scale * 100 - 1.)) * self.scale\n\n        else:\n            current_percentage = self.clr_iterations / self.mid_cycle_id\n            new_lr = self.initial_lr * (1. + current_percentage *\n                                        (self.scale * 100 - 1.)) * self.scale\n\n        if self.clr_iterations == self.num_iterations:\n            self.clr_iterations = 0\n\n        return new_lr\n\n    def compute_momentum(self):\n        \"\"\"\n         Compute the momentum based on which phase of the cycle it is in.\n\n        - If in the first half of training, the momentum gradually decreases.\n        - If in the second half of training, the momentum gradually increases.\n        - If in the final `end_percentage` portion of training, the momentum value\n            is kept constant at the maximum initial value.\n\n        # Returns:\n            the new momentum value\n        \"\"\"\n        if self.clr_iterations &gt; 2 * self.mid_cycle_id:\n            new_momentum = self.max_momentum\n\n        elif self.clr_iterations &gt; self.mid_cycle_id:\n            current_percentage = 1. - ((self.clr_iterations - self.mid_cycle_id) / float(\n                self.mid_cycle_id))\n            new_momentum = self.max_momentum - current_percentage * (\n                    self.max_momentum - self.min_momentum)\n\n        else:\n            current_percentage = self.clr_iterations / float(self.mid_cycle_id)\n            new_momentum = self.max_momentum - current_percentage * (\n                    self.max_momentum - self.min_momentum)\n\n        return new_momentum\n\n    def on_train_begin(self, logs={}):\n        logs = logs or {}\n\n        self.epochs = self.params['epochs']\n        # When fit generator is used\n        # self.params don't have the elements 'batch_size' and 'samples'\n        # self.batch_size = self.params['batch_size']\n        # self.samples = self.params['samples']\n        self.steps = self.params['steps']\n\n        if self.steps is not None:\n            self.num_iterations = self.epochs * self.steps\n        else:\n            if (self.samples % self.batch_size) == 0:\n                remainder = 0\n            else:\n                remainder = 1\n            self.num_iterations = (self.epochs + remainder) * self.samples // self.batch_size\n\n        self.mid_cycle_id = int(self.num_iterations * ((1. - self.end_percentage)) / float(2))\n\n        self._reset()\n        K.set_value(self.model.optimizer.lr, self.compute_lr())\n\n        if self._update_momentum:\n            if not hasattr(self.model.optimizer, 'momentum'):\n                raise ValueError(\"Momentum can be updated only on SGD optimizer !\")\n\n            new_momentum = self.compute_momentum()\n            K.set_value(self.model.optimizer.momentum, new_momentum)\n\n    def on_batch_end(self, epoch, logs=None):\n        logs = logs or {}\n\n        self.clr_iterations += 1\n        new_lr = self.compute_lr()\n\n        self.history.setdefault('lr', []).append(\n            K.get_value(self.model.optimizer.lr))\n        K.set_value(self.model.optimizer.lr, new_lr)\n\n        if self._update_momentum:\n            if not hasattr(self.model.optimizer, 'momentum'):\n                raise ValueError(\"Momentum can be updated only on SGD optimizer !\")\n\n            new_momentum = self.compute_momentum()\n\n            self.history.setdefault('momentum', []).append(\n                K.get_value(self.model.optimizer.momentum))\n            K.set_value(self.model.optimizer.momentum, new_momentum)\n\n        for k, v in logs.items():\n            self.history.setdefault(k, []).append(v)\n\n    def on_epoch_end(self, epoch, logs=None):\n        if self.verbose:\n            if self._update_momentum:\n                print(\" - lr: %0.5f - momentum: %0.2f \" %\n                      (self.history['lr'][-1], self.history['momentum'][-1]))\n\n            else:\n                print(\" - lr: %0.5f \" % (self.history['lr'][-1]))\n\n\nclass LRFinder(Callback):\n    def __init__(self,\n                 num_samples,\n                 batch_size,\n                 minimum_lr=1e-5,\n                 maximum_lr=10.,\n                 lr_scale='exp',\n                 validation_data=None,\n                 validation_sample_rate=5,\n                 stopping_criterion_factor=4.,\n                 loss_smoothing_beta=0.98,\n                 save_dir=None,\n                 verbose=True):\n        \"\"\"\n        This class uses the Cyclic Learning Rate history to find a\n        set of learning rates that can be good initializations for the\n        One-Cycle training proposed by Leslie Smith in the paper referenced\n        below.\n\n        A port of the Fast.ai implementation for Keras.\n\n        # Note\n        This requires that the model be trained for exactly 1 epoch. If the model\n        is trained for more epochs, then the metric calculations are only done for\n        the first epoch.\n\n        # Interpretation\n        Upon visualizing the loss plot, check where the loss starts to increase\n        rapidly. Choose a learning rate at somewhat prior to the corresponding\n        position in the plot for faster convergence. This will be the maximum_lr lr.\n        Choose the max value as this value when passing the `max_val` argument\n        to OneCycleLR callback.\n\n        Since the plot is in log-scale, you need to compute 10 ^ (-k) of the x-axis\n\n        # Arguments:\n            num_samples: Integer. Number of samples in the dataset.\n            batch_size: Integer. Batch size during training.\n            minimum_lr: Float. Initial learning rate (and the minimum).\n            maximum_lr: Float. Final learning rate (and the maximum).\n            lr_scale: Can be one of ['exp', 'linear']. Chooses the type of\n                scaling for each update to the learning rate during subsequent\n                batches. Choose 'exp' for large range and 'linear' for small range.\n            validation_data: Requires the validation dataset as a tuple of\n                (X, y) belonging to the validation set. If provided, will use the\n                validation set to compute the loss metrics. Else uses the training\n                batch loss. Will warn if not provided to alert the user.\n            validation_sample_rate: Positive or Negative Integer. Number of batches to sample from the\n                validation set per iteration of the LRFinder. Larger number of\n                samples will reduce the variance but will take longer time to execute\n                per batch.\n\n                If Positive &gt; 0, will sample from the validation dataset\n                If Megative, will use the entire dataset\n            stopping_criterion_factor: Integer or None. A factor which is used\n                to measure large increase in the loss value during training.\n                Since callbacks cannot stop training of a model, it will simply\n                stop logging the additional values from the epochs after this\n                stopping criterion has been met.\n                If None, this check will not be performed.\n            loss_smoothing_beta: Float. The smoothing factor for the moving\n                average of the loss function.\n            save_dir: Optional, String. If passed a directory path, the callback\n                will save the running loss and learning rates to two separate numpy\n                arrays inside this directory. If the directory in this path does not\n                exist, they will be created.\n            verbose: Whether to print the learning rate after every batch of training.\n\n        # References:\n            - [A disciplined approach to neural network hyper-parameters: Part 1 -- learning rate, batch size, weight_decay, and weight decay](https://arxiv.org/abs/1803.09820)\n        \"\"\"\n        super(LRFinder, self).__init__()\n\n        if lr_scale not in ['exp', 'linear']:\n            raise ValueError(\"`lr_scale` must be one of ['exp', 'linear']\")\n\n        if validation_data is not None:\n            self.validation_data = validation_data\n            self.use_validation_set = True\n\n            if validation_sample_rate &gt; 0 or validation_sample_rate &lt; 0:\n                self.validation_sample_rate = validation_sample_rate\n            else:\n                raise ValueError(\"`validation_sample_rate` must be a positive or negative integer other than o\")\n        else:\n            self.use_validation_set = False\n            self.validation_sample_rate = 0\n\n        self.num_samples = num_samples\n        self.batch_size = batch_size\n        self.initial_lr = minimum_lr\n        self.final_lr = maximum_lr\n        self.lr_scale = lr_scale\n        self.stopping_criterion_factor = stopping_criterion_factor\n        self.loss_smoothing_beta = loss_smoothing_beta\n        self.save_dir = save_dir\n        self.verbose = verbose\n\n        self.num_batches_ = num_samples // batch_size\n        self.current_lr_ = minimum_lr\n\n        if lr_scale == 'exp':\n            self.lr_multiplier_ = (maximum_lr / float(minimum_lr)) ** (\n                    1. / float(self.num_batches_))\n        else:\n            extra_batch = int((num_samples % batch_size) != 0)\n            self.lr_multiplier_ = np.linspace(\n                minimum_lr, maximum_lr, num=self.num_batches_ + extra_batch)\n\n        # If negative, use entire validation set\n        if self.validation_sample_rate &lt; 0:\n            self.validation_sample_rate = self.validation_data[0].shape[0] // batch_size\n\n        self.current_batch_ = 0\n        self.current_epoch_ = 0\n        self.best_loss_ = 1e6\n        self.running_loss_ = 0.\n\n        self.history = {}\n\n    def on_train_begin(self, logs=None):\n\n        self.current_epoch_ = 1\n        K.set_value(self.model.optimizer.lr, self.initial_lr)\n\n        warnings.simplefilter(\"ignore\")\n\n    def on_epoch_begin(self, epoch, logs=None):\n        self.current_batch_ = 0\n\n        if self.current_epoch_ &gt; 1:\n            warnings.warn(\n                \"\\n\\nLearning rate finder should be used only with a single epoch. \"\n                \"Hereafter, the callback will not measure the losses.\\n\\n\")\n\n    def on_batch_begin(self, batch, logs=None):\n        self.current_batch_ += 1\n\n    def on_batch_end(self, batch, logs=None):\n        if self.current_epoch_ &gt; 1:\n            return\n\n        if self.use_validation_set:\n            X, Y = self.validation_data[0], self.validation_data[1]\n\n            # use 5 random batches from test set for fast approximate of loss\n            num_samples = self.batch_size * self.validation_sample_rate\n\n            if num_samples &gt; X.shape[0]:\n                num_samples = X.shape[0]\n\n            idx = np.random.choice(X.shape[0], num_samples, replace=False)\n            x = X[idx]\n            y = Y[idx]\n\n            values = self.model.evaluate(x, y, batch_size=self.batch_size, verbose=False)\n            loss = values[0]\n        else:\n            loss = logs['loss']\n\n        # smooth the loss value and bias correct\n        running_loss = self.loss_smoothing_beta * loss + (\n                1. - self.loss_smoothing_beta) * loss\n        running_loss = running_loss / (\n                1. - self.loss_smoothing_beta ** self.current_batch_)\n\n        # stop logging if loss is too large\n        if self.current_batch_ &gt; 1 and self.stopping_criterion_factor is not None and (\n                running_loss &gt;\n                self.stopping_criterion_factor * self.best_loss_):\n\n            if self.verbose:\n                print(\" - LRFinder: Skipping iteration since loss is %d times as large as best loss (%0.4f)\"\n                      % (self.stopping_criterion_factor, self.best_loss_))\n            return\n\n        if running_loss &lt; self.best_loss_ or self.current_batch_ == 1:\n            self.best_loss_ = running_loss\n\n        current_lr = K.get_value(self.model.optimizer.lr)\n\n        self.history.setdefault('running_loss_', []).append(running_loss)\n        if self.lr_scale == 'exp':\n            self.history.setdefault('log_lrs', []).append(np.log10(current_lr))\n        else:\n            self.history.setdefault('log_lrs', []).append(current_lr)\n\n        # compute the lr for the next batch and update the optimizer lr\n        if self.lr_scale == 'exp':\n            current_lr *= self.lr_multiplier_\n        else:\n            current_lr = self.lr_multiplier_[self.current_batch_ - 1]\n\n        K.set_value(self.model.optimizer.lr, current_lr)\n\n        # save the other metrics as well\n        for k, v in logs.items():\n            self.history.setdefault(k, []).append(v)\n\n        if self.verbose:\n            if self.use_validation_set:\n                print(\" - LRFinder: val_loss: %1.4f - lr = %1.8f \" %\n                      (values[0], current_lr))\n            else:\n                print(\" - LRFinder: lr = %1.8f \" % current_lr)\n\n    def on_epoch_end(self, epoch, logs=None):\n        if self.save_dir is not None and self.current_epoch_ &lt;= 1:\n            if not os.path.exists(self.save_dir):\n                os.makedirs(self.save_dir)\n\n            losses_path = os.path.join(self.save_dir, 'losses.npy')\n            lrs_path = os.path.join(self.save_dir, 'lrs.npy')\n\n            np.save(losses_path, self.losses)\n            np.save(lrs_path, self.lrs)\n\n            if self.verbose:\n                print(\"\\tLR Finder : Saved the losses and learning rate values in path : {%s}\"\n                      % (self.save_dir))\n\n        self.current_epoch_ += 1\n\n        warnings.simplefilter(\"default\")\n\n    def plot_schedule(self, clip_beginning=None, clip_endding=None):\n        \"\"\"\n        Plots the schedule from the callback itself.\n\n        # Arguments:\n            clip_beginning: Integer or None. If positive integer, it will\n                remove the specified portion of the loss graph to remove the large\n                loss values in the beginning of the graph.\n            clip_endding: Integer or None. If negative integer, it will\n                remove the specified portion of the ending of the loss graph to\n                remove the sharp increase in the loss values at high learning rates.\n        \"\"\"\n        try:\n            import matplotlib.pyplot as plt\n            plt.style.use('seaborn-white')\n        except ImportError:\n            print(\n                \"Matplotlib not found. Please use `pip install matplotlib` first.\"\n            )\n            return\n\n        if clip_beginning is not None and clip_beginning &lt; 0:\n            clip_beginning = -clip_beginning\n\n        if clip_endding is not None and clip_endding &gt; 0:\n            clip_endding = -clip_endding\n\n        losses = self.losses\n        lrs = self.lrs\n\n        if clip_beginning:\n            losses = losses[clip_beginning:]\n            lrs = lrs[clip_beginning:]\n\n        if clip_endding:\n            losses = losses[:clip_endding]\n            lrs = lrs[:clip_endding]\n\n        plt.plot(lrs, losses)\n        plt.title('Learning rate vs Loss')\n        plt.xlabel('learning rate')\n        plt.ylabel('loss')\n        plt.show()\n\n    @classmethod\n    def restore_schedule_from_dir(cls,\n                                  directory,\n                                  clip_beginning=None,\n                                  clip_endding=None):\n        \"\"\"\n        Loads the training history from the saved numpy files in the given directory.\n\n        # Arguments:\n            directory: String. Path to the directory where the serialized numpy\n                arrays of the loss and learning rates are saved.\n            clip_beginning: Integer or None. If positive integer, it will\n                remove the specified portion of the loss graph to remove the large\n                loss values in the beginning of the graph.\n            clip_endding: Integer or None. If negative integer, it will\n                remove the specified portion of the ending of the loss graph to\n                remove the sharp increase in the loss values at high learning rates.\n\n        Returns:\n            tuple of (losses, learning rates)\n        \"\"\"\n        if clip_beginning is not None and clip_beginning &lt; 0:\n            clip_beginning = -clip_beginning\n\n        if clip_endding is not None and clip_endding &gt; 0:\n            clip_endding = -clip_endding\n\n        losses_path = os.path.join(directory, 'losses.npy')\n        lrs_path = os.path.join(directory, 'lrs.npy')\n\n        if not os.path.exists(losses_path) or not os.path.exists(lrs_path):\n            print(\"%s and %s could not be found at directory : {%s}\" %\n                  (losses_path, lrs_path, directory))\n\n            losses = None\n            lrs = None\n\n        else:\n            losses = np.load(losses_path)\n            lrs = np.load(lrs_path)\n\n            if clip_beginning:\n                losses = losses[clip_beginning:]\n                lrs = lrs[clip_beginning:]\n\n            if clip_endding:\n                losses = losses[:clip_endding]\n                lrs = lrs[:clip_endding]\n\n        return losses, lrs\n\n    @classmethod\n    def plot_schedule_from_file(cls,\n                                directory,\n                                clip_beginning=None,\n                                clip_endding=None):\n        \"\"\"\n        Plots the schedule from the saved numpy arrays of the loss and learning\n        rate values in the specified directory.\n\n        # Arguments:\n            directory: String. Path to the directory where the serialized numpy\n                arrays of the loss and learning rates are saved.\n            clip_beginning: Integer or None. If positive integer, it will\n                remove the specified portion of the loss graph to remove the large\n                loss values in the beginning of the graph.\n            clip_endding: Integer or None. If negative integer, it will\n                remove the specified portion of the ending of the loss graph to\n                remove the sharp increase in the loss values at high learning rates.\n        \"\"\"\n        try:\n            import matplotlib.pyplot as plt\n            plt.style.use('seaborn-white')\n        except ImportError:\n            print(\"Matplotlib not found. Please use `pip install matplotlib` first.\")\n            return\n\n        losses, lrs = cls.restore_schedule_from_dir(\n            directory,\n            clip_beginning=clip_beginning,\n            clip_endding=clip_endding)\n\n        if losses is None or lrs is None:\n            return\n        else:\n            plt.plot(lrs, losses)\n            plt.title('Learning rate vs Loss')\n            plt.xlabel('learning rate')\n            plt.ylabel('loss')\n            plt.show()\n\n    @property\n    def lrs(self):\n        return np.array(self.history['log_lrs'])\n\n    @property\n    def losses(self):\n        return np.array(self.history['running_loss_'])\n</code></pre>"}]}